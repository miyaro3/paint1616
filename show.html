<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Twitch Pixel Banner</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: transparent; 
            width: 900px;  /* 指定の横幅 */
            height: 100px; /* 指定の高さ */
        }
        #bg-layer { position: fixed; width: 100%; height: 100%; z-index: -1; }
        
        /* 絵と名前のセット（サイズを80px程度に縮小） */
        .art-container { 
            position: absolute; 
            width: 80px; 
            left: -80px; 
            will-change: left; 
            transition: opacity 0.5s, transform 0.5s; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* 名前ラベル（小さく調整） */
        .user-name {
            width: 100px; text-align: center; font-family: sans-serif; font-weight: bold; font-size: 11px;
            color: white; text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        
        /* ドット絵本体（16x16の1つを5pxにして 16*5=80px） */
        .pixel-art { display: grid; grid-template-columns: repeat(16, 5px); width: 80px; height: 80px; }
        .pixel { width: 5px; height: 5px; }

        @keyframes sparkle-anim {
            0% { filter: brightness(1); transform: scale(1); }
            50% { filter: brightness(1.8); transform: scale(1.1); }
            100% { filter: brightness(1); transform: scale(1); }
        }
        .sparkle { animation: sparkle-anim 0.5s infinite; }
        .explode { transform: scale(2); opacity: 0; filter: blur(5px); pointer-events: none; }

        #speed-notify {
            position: fixed; bottom: 5px; right: 5px; color: #0f0; font-family: monospace;
            background: rgba(0,0,0,0.7); padding: 2px 5px; border-radius: 3px;
            opacity: 0; transition: opacity 0.5s; font-size: 10px;
        }
    </style>
</head>
<body>
    <div id="bg-layer"></div>
    <div id="wrapper"></div>
    <div id="speed-notify"></div>

    <script>
// ==========================================
// 【設定エリア】
// ==========================================
// URLから「channel」パラメータを取得。指定がなければ空文字にする
const urlParams = new URLSearchParams(window.location.search);
const CHANNEL_NAME = urlParams.get('channel') || ''; 

let currentSpeed = 0.8;       // 横長なので少し速めがおすすめ
const SPEED_STEP = 2;
const BG_COLOR = 'transparent';


        const ART_TOP = 5;            // 上からの位置
        const MARGIN = 40;            // 絵と絵の隙間
        const MAX_POOL_SIZE = 50;     
        const PALETTE = ['transparent', '#ffffff', '#888888', '#222222', '#ff4b2b', '#33cc33', '#0077ff', '#ffee00', '#ff99cc', '#66ffff', '#ccff33', '#8b4513', '#b22222', '#000080', '#ff8c00', '#9933ff'];
        // ==========================================

        const wrapper = document.getElementById('wrapper');
        const speedNotify = document.getElementById('speed-notify');
        document.getElementById('bg-layer').style.backgroundColor = BG_COLOR;

        let activeArts = [];
        let pool = [];
        let poolIndex = 0;
        const ART_WIDTH = 80; // 縮小後の横幅

        function showSpeed() {
            speedNotify.innerText = `Spd: ${currentSpeed.toFixed(1)}`;
            speedNotify.style.opacity = 1;
            setTimeout(() => { speedNotify.style.opacity = 0; }, 2000);
        }

        function createArt(code, userName) {
            const container = document.createElement('div');
            container.className = 'art-container';
            container.style.top = ART_TOP + 'px';

            const nameLabel = document.createElement('div');
            nameLabel.className = 'user-name';
            nameLabel.innerText = userName;
            container.appendChild(nameLabel);

            const artDiv = document.createElement('div');
            artDiv.className = 'pixel-art';
            
            let pIdx = 0;
            const pixelColors = new Array(256).fill('transparent');
            for (let i = 0; i < code.length; i += 2) {
                const color = PALETTE[parseInt(code[i], 16)] || 'transparent';
                const count = parseInt(code[i+1], 16);
                for (let j = 0; j < count; j++) {
                    if (pIdx < 256) pixelColors[pIdx] = color;
                    pIdx++;
                }
            }
            pixelColors.forEach(color => {
                const p = document.createElement('div');
                p.className = 'pixel';
                p.style.backgroundColor = color;
                artDiv.appendChild(p);
            });
            container.appendChild(artDiv);

            return { el: container, code: code, userName: userName, left: -(ART_WIDTH + MARGIN) };
        }

        function update() {
            for (let i = 0; i < activeArts.length; i++) {
                const art = activeArts[i];
                let canMove = false;
                if (i === 0) {
                    canMove = true;
                } else {
                    const prevArt = activeArts[i-1];
                    if (prevArt.left > art.left + ART_WIDTH + MARGIN) {
                        canMove = true;
                    }
                }
                if (canMove) {
                    art.left += currentSpeed;
                    art.el.style.left = art.left + 'px';
                }
            }
            // 900pxを超えたらループ
            if (activeArts.length > 0 && activeArts[0].left > 900) {
                const finishedArt = activeArts.shift();
                finishedArt.left = -(ART_WIDTH + MARGIN);
                finishedArt.el.style.left = finishedArt.left + 'px';
                activeArts.push(finishedArt);
            }
            requestAnimationFrame(update);
        }
        update();

        function connect() {
            const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
            socket.onopen = () => {
                socket.send('CAP REQ :twitch.tv/commands twitch.tv/tags');
                socket.send('NICK justinfan' + Math.floor(Math.random() * 10000));
                socket.send('JOIN #' + CHANNEL_NAME);
            };
            socket.onmessage = (event) => {
                const msg = event.data;
                if (msg.startsWith('PING')) { socket.send('PONG :tmi.twitch.tv'); return; }
                if (msg.includes('PRIVMSG')) {
                    const nameMatch = msg.match(/display-name=([^; ]+)/);
                    const userName = nameMatch ? nameMatch[1] : "Anon";
                    const chatText = msg.split('PRIVMSG #' + CHANNEL_NAME + ' :')[1]?.trim();
                    if (!chatText) return;

                    if (chatText === '!sparkle' || chatText === '!bomb' || chatText === '!clear') {
                        activeArts.forEach((art) => {
                            if (art.userName === userName) {
                                if (chatText === '!sparkle') {
                                    art.el.classList.add('sparkle');
                                    setTimeout(() => art.el.classList.remove('sparkle'), 7000);
                                } else if (chatText === '!bomb') {
                                    art.el.classList.add('explode');
                                    setTimeout(() => removeArt(art), 600);
                                } else if (chatText === '!clear') {
                                    removeArt(art);
                                }
                            }
                        });
                        return;
                    }

                    if (chatText === '!fast') { currentSpeed = Math.min(5.0, currentSpeed + SPEED_STEP); showSpeed(); return; }
                    if (chatText === '!slow') { currentSpeed = Math.max(0.1, currentSpeed - SPEED_STEP); showSpeed(); return; }

                    if (chatText.startsWith('!draw ')) {
                        const code = chatText.replace('!draw ', '');
                        if (pool.length < MAX_POOL_SIZE) {
                            const artObj = createArt(code, userName);
                            pool.push(artObj); activeArts.push(artObj);
                            wrapper.appendChild(artObj.el);
                        } else {
                            const targetArt = pool[poolIndex];
                            const newArtObj = createArt(code, userName);
                            targetArt.el.innerHTML = newArtObj.el.innerHTML;
                            targetArt.userName = userName;
                            poolIndex = (poolIndex + 1) % MAX_POOL_SIZE;
                        }
                    }
                }
            };
            socket.onclose = () => setTimeout(connect, 3000);
        }

        function removeArt(artObj) {
            artObj.el.remove();
            activeArts = activeArts.filter(a => a !== artObj);
            pool = pool.filter(p => p !== artObj);
        }
        connect();
    </script>
</body>
</html>
